Code Collection - Created on 2024-11-08 19:58:07.764701
================================================================================

File: config.py
--------------------------------------------------------------------------------
# File: config.py

import os

# Get the directory of the current script
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Database
DB_FILE = os.path.join(BASE_DIR, 'insider_portfolio.db')

================================================================================

File: controllers\import_transactions_controller.py
--------------------------------------------------------------------------------
# File: controllers/import_transactions_controller.py

import pandas as pd
import os
import shutil
import logging
from datetime import datetime
import yfinance as yf
from PySide6.QtWidgets import QFileDialog, QMessageBox
from PySide6.QtCore import QObject, Signal
from models.transaction import Transaction
from models.stock import Stock
from views.import_transactions_view import ImportTransactionsView
from views.verify_transactions_view import VerifyTransactionsDialog

logging.basicConfig(level=logging.DEBUG, filename='import_transactions.log', filemode='w',
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ImportTransactionsController(QObject):
    import_completed = Signal()

    def __init__(self, portfolio, db_manager):
        super().__init__()
        self.portfolio = portfolio
        self.db_manager = db_manager
        self.view = ImportTransactionsView()

        self.view.import_transactions.connect(self.import_transactions)
        self.view.get_template.connect(self.provide_template)

    def import_transactions(self, file_name, column_mapping):
        try:
            logger.info(f"Starting import from file: {file_name}")
            # Read the file
            if file_name.endswith('.xlsx'):
                df = pd.read_excel(file_name, parse_dates=['Trade Date'])
            elif file_name.endswith('.csv'):
                df = pd.read_csv(file_name, parse_dates=['Trade Date'])
            else:
                raise ValueError("Unsupported file format")

            if column_mapping:
                df = df.rename(columns=column_mapping)

            # Convert 'Trade Date' to date only (no time information)
            df['Trade Date'] = df['Trade Date'].dt.date

            # Show verification dialog
            dialog = VerifyTransactionsDialog(df, self.db_manager, self.view)
            dialog.verification_completed.connect(self.on_verification_completed)
            
            if dialog.exec_():
                logger.info("Transaction verification completed successfully")
            else:
                logger.info("Transaction verification cancelled by user")
                return

        except Exception as e:
            error_msg = f"Failed to import transactions: {str(e)}"
            logger.exception(error_msg)
            QMessageBox.warning(self.view, "Import Failed", error_msg)

    def on_verification_completed(self, verification_results):
        try:
            market_mappings = verification_results['market_mappings']
            stock_data = verification_results['stock_data']
            df = verification_results['transactions_df']  # Get back the verified DataFrame

            # Ask about historical data
            response = QMessageBox.question(
                self.view,
                "Historical Data",
                "Would you like to collect historical price data for verified stocks?\n"
                "This process might take several minutes.",
                QMessageBox.Yes | QMessageBox.No
            )
            collect_history = response == QMessageBox.Yes

            # Group transactions by instrument_code for efficiency
            for instrument_code, group in df.groupby('Instrument Code'):
                # Get market suffix and create yahoo symbol
                market_suffix = market_mappings.get(instrument_code, '')
                yahoo_symbol = f"{instrument_code}{market_suffix}" if market_suffix else instrument_code

                # Create or get stock
                stock = Stock.get_by_yahoo_symbol(yahoo_symbol, self.db_manager)
                if not stock:
                    stock_info = stock_data.get(instrument_code, {})
                    stock = Stock.create(
                        yahoo_symbol=yahoo_symbol,
                        instrument_code=instrument_code,
                        name=stock_info.get('name', ''),
                        current_price=stock_info.get('price', 0.0),
                        db_manager=self.db_manager
                    )
                    self.portfolio.add_stock(stock)

                # Bulk insert transactions for this stock
                transactions = []
                for _, row in group.iterrows():
                    transactions.append((
                        stock.id,
                        row['Trade Date'],
                        row['Quantity'],
                        row['Price'],
                        row['Transaction Type'],
                        row['Quantity'],  # original_quantity
                        row['Price']      # original_price
                    ))
                
                self.db_manager.bulk_insert_transactions(transactions)

                # Update stock splits if any
                if instrument_code in stock_data and 'splits' in stock_data[instrument_code]:
                    splits = stock_data[instrument_code]['splits']
                    split_data = [
                        (stock.id, date.strftime('%Y-%m-%d'), ratio, 'yahoo', datetime.now())
                        for date, ratio in splits.items()
                    ]
                    self.db_manager.bulk_insert_stock_splits(split_data)

            if collect_history:
                self.collect_historical_data(df)

            QMessageBox.information(self.view, "Import Successful", 
                                  "Transactions have been imported successfully.")
            self.import_completed.emit()

        except Exception as e:
            error_msg = f"Failed to process verified transactions: {str(e)}"
            logger.exception(error_msg)
            QMessageBox.warning(self.view, "Import Failed", error_msg)

    def collect_historical_data(self, df):
        # Group by instrument code and get date ranges
        date_ranges = df.groupby('Instrument Code').agg({
            'Trade Date': ['min', 'max']
        }).reset_index()
        date_ranges.columns = ['instrument_code', 'start_date', 'end_date']

        # Collect and store historical data for each stock
        for _, row in date_ranges.iterrows():
            try:
                stock = self.portfolio.get_stock(row['instrument_code'])
                if stock:
                    ticker = yf.Ticker(stock.yahoo_symbol)
                    history = ticker.history(
                        start=row['start_date'],
                        end=row['end_date'],
                        interval='1d'
                    )
                    
                    # Prepare bulk insert data
                    historical_prices = [
                        (
                            stock.id,
                            index.strftime('%Y-%m-%d'),
                            row_data['Open'],
                            row_data['High'],
                            row_data['Low'],
                            row_data['Close'],
                            row_data['Volume'],
                            row_data['Close'],  # adjusted_close
                            row_data['Close'],  # original_close
                            False               # split_adjusted
                        )
                        for index, row_data in history.iterrows()
                    ]
                    
                    self.db_manager.bulk_insert_historical_prices(historical_prices)
                    
            except Exception as e:
                logger.error(f"Failed to collect historical data for {row['instrument_code']}: {str(e)}")

    def provide_template(self):
        current_dir = os.path.dirname(os.path.abspath(__file__))
        template_path = os.path.join(current_dir, "..", "Transaction_Data_Template.xlsx")
        
        if not os.path.exists(template_path):
            QMessageBox.warning(self.view, "Template Not Found", 
                              "The template file is missing from the application directory.")
            return

        save_path, _ = QFileDialog.getSaveFileName(
            self.view,
            "Save Template",
            "Transaction_Data_Template.xlsx",
            "Excel Files (*.xlsx)"
        )
        if save_path:
            shutil.copy2(template_path, save_path)
            QMessageBox.information(self.view, "Template Saved", 
                                  f"Template has been saved to {save_path}")

    def show_view(self):
        self.view.show()

================================================================================

File: controllers\portfolio_controller.py
--------------------------------------------------------------------------------
# File: controllers/portfolio_controller.py

from typing import List
from models.portfolio import Portfolio
from views.manage_portfolios_view import ManagePortfoliosView
from controllers.import_transactions_controller import ImportTransactionsController

class PortfolioController:
    def __init__(self, db_manager):
        self.db_manager = db_manager
        self.portfolios: List[Portfolio] = []
        self.view = ManagePortfoliosView()
        self.import_controller = None

        # Connect view signals to controller methods
        self.view.create_portfolio.connect(self.create_portfolio)
        self.view.select_portfolio.connect(self.select_portfolio)
        self.view.delete_portfolio.connect(self.delete_portfolio)
        self.view.import_transactions.connect(self.import_transactions)

    def load_portfolios(self):
        self.portfolios = Portfolio.get_all(self.db_manager)
        self.update_view()

    def create_portfolio(self, name: str):
        new_portfolio = Portfolio.create(name, self.db_manager)
        self.portfolios.append(new_portfolio)
        self.update_view()

    def select_portfolio(self, name: str):
        selected_portfolio = next((p for p in self.portfolios if p.name == name), None)
        if selected_portfolio:
            # Here you would typically switch to a detailed view of the selected portfolio
            print(f"Selected portfolio: {selected_portfolio.name}")
            # You might emit a signal here to tell the main window to switch views
        else:
            print(f"Portfolio '{name}' not found")

    def delete_portfolio(self, name: str):
        portfolio_to_delete = next((p for p in self.portfolios if p.name == name), None)
        if portfolio_to_delete:
            self.db_manager.delete_portfolio(portfolio_to_delete.id)
            self.portfolios = [p for p in self.portfolios if p.name != name]
            self.update_view()

    def import_transactions(self, portfolio_name: str):
        portfolio = next((p for p in self.portfolios if p.name == portfolio_name), None)
        if portfolio:
            self.import_controller = ImportTransactionsController(portfolio, self.db_manager)
            self.import_controller.import_completed.connect(self.on_import_completed)
            self.import_controller.show_view()
        else:
            print(f"Portfolio '{portfolio_name}' not found")

    def on_import_completed(self):
        # This method will be called when the import is completed
        self.load_portfolios()  # Reload all portfolios to reflect changes
        # You might want to emit a signal here to update other views

    def update_view(self):
        self.view.update_portfolios(self.portfolios)

    def get_view(self):
        return self.view
    
    def get_portfolio_by_name(self, name: str) -> Portfolio:
        return next((p for p in self.portfolios if p.name == name), None)

================================================================================

File: controllers\portfolio_view_controller.py
--------------------------------------------------------------------------------
# File: controllers/portfolio_view_controller.py

from PySide6.QtWidgets import QInputDialog, QMessageBox
from views.my_portfolio_view import MyPortfolioView
from models.portfolio import Portfolio
from models.stock import Stock
from models.transaction import Transaction
from datetime import datetime
import yfinance as yf

class PortfolioViewController:
    def __init__(self, db_manager):
        self.db_manager = db_manager
        self.view = MyPortfolioView()
        self.current_portfolio = None

        # Connect view signals to controller methods
        self.view.add_stock.connect(self.add_stock)
        self.view.remove_stock.connect(self.remove_stock)
        self.view.refresh_data.connect(self.refresh_data)

    def set_portfolio(self, portfolio: Portfolio):
        self.current_portfolio = portfolio
        self.current_portfolio.load_stocks()
        self.refresh_data()

    def update_view(self):
        if self.current_portfolio:
            self.view.update_portfolio(self.current_portfolio)

    def add_stock(self):
        if not self.current_portfolio:
            return

        instrument_code, ok = QInputDialog.getText(self.view, "Add Stock", "Enter stock symbol:")
        if ok and instrument_code:
            quantity, ok = QInputDialog.getInt(self.view, "Add Stock", f"Enter quantity for {instrument_code}:", min=1)
            if ok:
                try:
                    # Fetch basic stock info
                    ticker = yf.Ticker(instrument_code)
                    info = ticker.info
                    yahoo_symbol = info['symbol']
                    stock_name = info.get('longName', instrument_code)
                    current_price = info.get('currentPrice', 0.0)

                    # Create new stock and add to portfolio
                    new_stock = Stock.create(yahoo_symbol, instrument_code, stock_name, current_price, self.db_manager)
                    self.current_portfolio.add_stock(new_stock)
                    
                    # Add transaction
                    Transaction.create(new_stock.id, datetime.now(), quantity, current_price, "BUY", self.db_manager)
                    
                    self.update_view()
                except Exception as e:
                    QMessageBox.warning(self.view, "Error", f"Failed to add stock: {str(e)}")

    def remove_stock(self, yahoo_symbol: str):
        if not self.current_portfolio:
            return

        confirm = QMessageBox.question(self.view, "Confirm Removal",
                                       f"Are you sure you want to remove {yahoo_symbol} from the portfolio?",
                                       QMessageBox.Yes | QMessageBox.No)
        if confirm == QMessageBox.Yes:
            self.current_portfolio.remove_stock(yahoo_symbol)
            self.update_view()

    def refresh_data(self):
        if not self.current_portfolio:
            return

        for stock in self.current_portfolio.stocks.values():
            try:
                # In a real application, you would fetch the current price from an API
                # For now, we'll just update the last_updated timestamp
                stock.update_price()
            except Exception as e:
                print(f"Failed to update price for {stock.yahoo_symbol}: {str(e)}")
        self.update_view()

    def get_view(self):
        return self.view

================================================================================

File: database\database_manager.py
--------------------------------------------------------------------------------
# File: database/database_manager.py

import sqlite3
from datetime import datetime
import os

class DatabaseManager:
    def __init__(self, db_file):
        self.db_file = db_file
        self.conn = None
        self.cursor = None

    def connect(self):
        self.conn = sqlite3.connect(self.db_file)
        self.cursor = self.conn.cursor()

    def disconnect(self):
        if self.conn:
            self.conn.close()

    def init_db(self):
        current_dir = os.path.dirname(os.path.abspath(__file__))
        schema_file = os.path.join(current_dir, 'schema.sql')
        with open(schema_file, 'r') as f:
            schema = f.read()
        self.conn.executescript(schema)
        self.conn.commit()

    def execute(self, sql, params=None):
        if params is None:
            self.cursor.execute(sql)
        else:
            self.cursor.execute(sql, params)
        self.conn.commit()

    def fetch_one(self, sql, params=None):
        if params is None:
            self.cursor.execute(sql)
        else:
            self.cursor.execute(sql, params)
        return self.cursor.fetchone()

    def fetch_all(self, sql, params=None):
        if params is None:
            self.cursor.execute(sql)
        else:
            self.cursor.execute(sql, params)
        return self.cursor.fetchall()

    # Portfolio methods
    def create_portfolio(self, name):
        self.execute("INSERT INTO portfolios (name) VALUES (?)", (name,))
        return self.cursor.lastrowid

    def get_all_portfolios(self):
        return self.fetch_all("SELECT id, name FROM portfolios")

    def delete_portfolio(self, portfolio_id):
        self.execute("DELETE FROM portfolios WHERE id = ?", (portfolio_id,))

    # Stock methods
    def add_stock(self, yahoo_symbol, instrument_code, name=None, current_price=None):
        current_time = datetime.now().replace(microsecond=0)
        self.execute("""
            INSERT OR REPLACE INTO stocks (yahoo_symbol, instrument_code, name, current_price, last_updated)
            VALUES (?, ?, ?, ?, ?)
        """, (yahoo_symbol, instrument_code, name, current_price, current_time))
        return self.cursor.lastrowid

    def update_stock_price(self, yahoo_symbol, current_price):
        current_time = datetime.now().replace(microsecond=0)
        self.execute("""
            UPDATE stocks SET current_price = ?, last_updated = ? WHERE yahoo_symbol = ?
        """, (current_price, current_time, yahoo_symbol))

    def get_stock(self, yahoo_symbol):
        return self.fetch_one("SELECT * FROM stocks WHERE yahoo_symbol = ?", (yahoo_symbol,))

    # Transaction methods
    def add_transaction(self, stock_id, date, quantity, price, transaction_type):
        self.execute("""
            INSERT INTO transactions (stock_id, date, quantity, price, transaction_type)
            VALUES (?, ?, ?, ?, ?)
        """, (stock_id, date, quantity, price, transaction_type))

    def get_transactions_for_stock(self, stock_id):
        return self.fetch_all("""
            SELECT id, date, quantity, price, transaction_type
            FROM transactions
            WHERE stock_id = ?
            ORDER BY date
        """, (stock_id,))
    
    def bulk_insert_transactions(self, transactions):
        """
        Bulk insert transactions.
        transactions: list of tuples (stock_id, date, quantity, price, type, original_quantity, original_price)
        """
        self.cursor.executemany("""
            INSERT INTO transactions 
            (stock_id, date, quantity, price, transaction_type, original_quantity, original_price)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, transactions)
        self.conn.commit()

    def bulk_insert_stock_splits(self, splits):
        """
        Bulk insert stock splits.
        splits: list of tuples (stock_id, date, ratio, verified_source, verification_date)
        """
        self.cursor.executemany("""
            INSERT INTO stock_splits 
            (stock_id, date, ratio, verified_source, verification_date)
            VALUES (?, ?, ?, ?, ?)
        """, splits)
        self.conn.commit()

    def bulk_insert_historical_prices(self, prices):
        """
        Bulk insert historical prices.
        prices: list of tuples (stock_id, date, open, high, low, close, volume, adjusted_close, 
                            original_close, split_adjusted)
        """
        self.cursor.executemany("""
            INSERT INTO historical_prices 
            (stock_id, date, open_price, high_price, low_price, close_price, volume, 
            adjusted_close, original_close, split_adjusted)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, prices)
        self.conn.commit()

    # Portfolio-Stock relationship methods
    def add_stock_to_portfolio(self, portfolio_id, stock_id):
        self.execute("""
            INSERT OR IGNORE INTO portfolio_stocks (portfolio_id, stock_id)
            VALUES (?, ?)
        """, (portfolio_id, stock_id))

    def remove_stock_from_portfolio(self, portfolio_id, stock_id):
        self.execute("""
            DELETE FROM portfolio_stocks
            WHERE portfolio_id = ? AND stock_id = ?
        """, (portfolio_id, stock_id))

    def get_stocks_for_portfolio(self, portfolio_id):
        return self.fetch_all("""
            SELECT s.id, s.yahoo_symbol, s.instrument_code, s.name, s.current_price, s.last_updated
            FROM stocks s
            JOIN portfolio_stocks ps ON s.id = ps.stock_id
            WHERE ps.portfolio_id = ?
        """, (portfolio_id,))

    # Stock split methods
    def add_stock_split(self, stock_id, date, ratio):
        self.execute("""
            INSERT INTO stock_splits (stock_id, date, ratio)
            VALUES (?, ?, ?)
        """, (stock_id, date, ratio))

    def get_stock_splits(self, stock_id):
        return self.fetch_all("""
            SELECT date, ratio FROM stock_splits
            WHERE stock_id = ?
            ORDER BY date
        """, (stock_id,))
    
    # Dividend Reinvestment Plan methods
    def get_stock_drp(self, stock_id):
        result = self.fetch_one("SELECT drp FROM stocks WHERE id = ?", (stock_id,))
        return bool(result[0]) if result and result[0] is not None else False

    def update_stock_drp(self, stock_id, drp_status):
        self.execute("""
            UPDATE stocks 
            SET drp = ?
            WHERE id = ?
        """, (1 if drp_status else 0, stock_id))
        self.conn.commit()
        print(f"Database updated: Stock ID {stock_id} DRP status set to {drp_status}") 

    # Market code methods
    def get_all_market_codes(self):
        return self.fetch_all("SELECT market_or_index, market_suffix FROM market_codes")

    def get_market_code_suffix(self, market_or_index):
        result = self.fetch_one("SELECT market_suffix FROM market_codes WHERE market_or_index = ?", (market_or_index,))
        return result[0] if result else None

    def update_stock_yahoo_symbol(self, instrument_code, yahoo_symbol):
        self.execute("UPDATE stocks SET yahoo_symbol = ? WHERE instrument_code = ?", (yahoo_symbol, instrument_code))

    def update_stock_market(self, instrument_code, market_suffix):
        self.execute("""
            UPDATE stocks 
            SET market_suffix = ?
            WHERE instrument_code = ?
        """, (market_suffix, instrument_code))

    def get_all_stocks(self):
        return self.fetch_all("""
            SELECT id, yahoo_symbol, instrument_code, name, current_price, last_updated, market_suffix, drp
            FROM stocks
        """)
    
    def get_stock(self, instrument_code):
        return self.fetch_one("""
            SELECT id, yahoo_symbol, instrument_code, name, current_price, last_updated, market_suffix
            FROM stocks
            WHERE instrument_code = ?
        """, (instrument_code,))

================================================================================

File: database\schema.sql
--------------------------------------------------------------------------------
-- File: database/schema.sql

-- Portfolios table
CREATE TABLE IF NOT EXISTS portfolios (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);

-- Stocks table
CREATE TABLE IF NOT EXISTS stocks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    yahoo_symbol TEXT NOT NULL,
    instrument_code TEXT NOT NULL,
    name TEXT,
    current_price REAL,
    last_updated DATETIME,
    market_suffix TEXT,
    verification_status TEXT DEFAULT 'pending', -- New: tracks verification status (pending, verified, failed)
    last_verified DATETIME,                    -- New: when the stock was last verified with Yahoo
    drp INTEGER DEFAULT 0,
    UNIQUE(yahoo_symbol, instrument_code)
);

-- Portfolio_Stocks table (for many-to-many relationship)
CREATE TABLE IF NOT EXISTS portfolio_stocks (
    portfolio_id INTEGER,
    stock_id INTEGER,
    PRIMARY KEY (portfolio_id, stock_id),
    FOREIGN KEY (portfolio_id) REFERENCES portfolios(id) ON DELETE CASCADE,
    FOREIGN KEY (stock_id) REFERENCES stocks(id) ON DELETE CASCADE
);

-- Transactions table
CREATE TABLE IF NOT EXISTS transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    stock_id INTEGER,
    date DATETIME NOT NULL,
    quantity REAL NOT NULL,
    price REAL NOT NULL,
    transaction_type TEXT NOT NULL,
    original_quantity REAL,    -- New: stores pre-split quantity
    original_price REAL,       -- New: stores pre-split price
    FOREIGN KEY (stock_id) REFERENCES stocks(id) ON DELETE CASCADE
);

-- Stock_Splits table
CREATE TABLE IF NOT EXISTS stock_splits (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    stock_id INTEGER,
    date DATE NOT NULL,
    ratio REAL NOT NULL,
    verified_source TEXT,      -- New: indicates if split came from Yahoo or manual entry
    verification_date DATETIME, -- New: when the split was verified
    FOREIGN KEY (stock_id) REFERENCES stocks(id) ON DELETE CASCADE
);

-- Historical_Prices table (new)
CREATE TABLE IF NOT EXISTS historical_prices (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    stock_id INTEGER NOT NULL,
    date DATE NOT NULL,
    open_price REAL,
    high_price REAL,
    low_price REAL,
    close_price REAL,
    volume INTEGER,
    adjusted_close REAL,
    original_close REAL,      -- Stores pre-split price
    split_adjusted BOOLEAN,   -- Indicates if price has been adjusted for splits
    FOREIGN KEY (stock_id) REFERENCES stocks(id) ON DELETE CASCADE,
    UNIQUE(stock_id, date)
);

-- Import_Verification table (new)
CREATE TABLE IF NOT EXISTS import_verification (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    import_date DATETIME NOT NULL,
    portfolio_id INTEGER,
    stock_id INTEGER,
    verification_status TEXT,
    verification_notes TEXT,
    FOREIGN KEY (portfolio_id) REFERENCES portfolios(id) ON DELETE CASCADE,
    FOREIGN KEY (stock_id) REFERENCES stocks(id) ON DELETE CASCADE
);

-- Market_Codes table
CREATE TABLE IF NOT EXISTS market_codes (
    market_or_index TEXT NOT NULL PRIMARY KEY,
    market_suffix TEXT NOT NULL UNIQUE
);

-- Yahoo market codes
-- Could look to use an API call to populate this in the future
INSERT OR IGNORE INTO market_codes (market_or_index, market_suffix) VALUES
('Argentina - Buenos Aires Stock Exchange (BYMA)', '.BA'),
('Australia - Australian Stock Exchange', '.AX'),
('Austria - Vienna Stock Exchange', '.VI'),
('Belgium - Euronext Brussels', '.BR'),
('Brazil - Sao Paolo Stock Exchange (BOVESPA)', '.SA'),
('Canada - Canadian Securities Exchange Toronto Stock Exchange', '.CN'),
('Canada - NEO Exchange', '.NE'),
('Canada - Toronto Stock Exchange', '.TO'),
('Canada - TSX Venture Exchange (TSXV)', '.V'),
('Chile - Santiago Stock Exchange', '.SN'),
('China - Shanghai Stock Exchange', '.SS'),
('China - Shenzhen Stock Exchange', '.SZ'),
('Czech Republic - Prague Stock Exchange Index', '.PR'),
('Denmark - Nasdaq OMX Copenhagen', '.CO'),
('Egypt - Egyptian Exchange Index (EGID)', '.CA'),
('Estonia - Nasdaq OMX Tallinn', '.TL'),
('Finland - Nasdaq OMX Helsinki', '.HE'),
('France - Euronext', '.NX'),
('France - Euronext Paris', '.PA'),
('Germany - Berlin Stock Exchange', '.BE'),
('Germany - Bremen Stock Exchange', '.BM'),
('Germany - Dusseldorf Stock Exchange', '.DU'),
('Germany - Frankfurt Stock Exchange', '.F'),
('Germany - Hamburg Stock Exchange', '.HM'),
('Germany - Hanover Stock Exchange', '.HA'),
('Germany - Munich Stock Exchange', '.MU'),
('Germany - Stuttgart Stock Exchange', '.SG'),
('Germany - Deutsche Boerse XETRA', '.DE'),
('Global - Currency Rates', ''),
('Greece - Athens Stock Exchange (ATHEX)', '.AT'),
('Hong Kong - Hong Kong Stock Exchange (HKEX)', '.HK'),
('Hungary - Budapest Stock Exchange', '.BD'),
('Iceland - Nasdaq OMX Iceland', '.IC'),
('India - Bombay Stock Exchange', '.BO'),
('India - National Stock Exchange of India', '.NS'),
('Indonesia - Indonesia Stock Exchange (IDX)', '.JK'),
('Ireland - Euronext Dublin', '.IR'),
('Israel - Tel Aviv Stock Exchange', '.TA'),
('Italy - EuroTLX', '.TI'),
('Italy - Italian Stock Exchange, former Milano', '.MI'),
('Japan - Nikkei Indices', ''),
('Japan - Tokyo Stock Exchange', '.T'),
('Latvia - Nasdaq OMX Riga', '.RG'),
('Lithuania - Nasdaq OMX Vilnius', '.VS'),
('Malaysia - Malaysian Stock Exchange', '.KL'),
('Mexico - Mexico Stock Exchange (BMV)', '.MX'),
('Netherlands - Euronext Amsterdam', '.AS'),
('New Zealand - New Zealand Stock Exchange (NZX)', '.NZ'),
('Norway - Oslo Stock Exchange', '.OL'),
('Portugal - Euronext Lisbon', '.LS'),
('Qatar - Qatar Stock Exchange', '.QA'),
('Russia - Moscow Exchange (MOEX)', '.ME'),
('Singapore - Singapore Stock Exchange', '.SI'),
('South Africa - Johannesburg Stock Exchange', '.Jo'),
('South Korea - Korea Stock Exchange', '.KS'),
('South Korea - KOSDAQ', '.KQ'),
('Spain - Madrid SE C.A.T.S.', '.MC'),
('Saudi Arabia - Saudi Stock Exchange (Tadawul)', '.SAU'),
('Sweden - Nasdaq OMX Stockholm', '.ST'),
('Switzerland - Swiss Exchange (SIX)', '.SW'),
('Taiwan - Taiwan OTC Exchange', '.TWO'),
('Taiwan - Taiwan Stock Exchange (TWSE)', '.TW'),
('Thailand - Stock Exchange of Thailand (SET)', '.BK'),
('Turkey - Borsa İstanbul', '.IS'),
('United Kingdom - FTSE Indices', ''),
('United Kingdom - London Stock Exchange', '.L'),
('United Kingdom - London Stock Exchange', '.IL'),
('United States of America - Chicago Board of Trade (CBOT)', '.CBT'),
('United States of America - Chicago Mercantile Exchange (CME)', '.CME'),
('United States of America - Dow Jones Indexes', ''),
('United States of America - NASDAQ Stock Exchange', ''),
('United States of America - ICE Futures US, former New York Board of Trade', '.NYB'),
('United States of America - New York Commodities Exchange (COMEX)', '.CMX'),
('United States of America - New York Mercantile Exchange (NYMEX)', '.NYM'),
('United States of America - Options Price Reporting Authority (OPRA)', ''),
('United States of America - OTC Bulletin Board Market', ''),
('United States of America - OTC Markets Group', ''),
('United States of America - S & P Indices', ''),
('Venezuela - Caracas Stock Exchange', '.CR');

================================================================================

File: main.py
--------------------------------------------------------------------------------
# File: main.py

import sys
from PySide6.QtWidgets import QApplication
from views.main_window import MainWindow
from database.database_manager import DatabaseManager
import config

def main():
    app = QApplication(sys.argv)

    # Initialise DatabaseManager
    db_manager = DatabaseManager(config.DB_FILE)
    db_manager.connect()
    db_manager.init_db()

    # Create main window
    window = MainWindow(db_manager)
    window.show()

    # Run the application
    exit_code = app.exec()

    # Clean up
    db_manager.disconnect()

    sys.exit(exit_code)

if __name__ == "__main__":
    main()

================================================================================

File: models\portfolio.py
--------------------------------------------------------------------------------
# File: models/portfolio.py

from typing import Dict
from .stock import Stock

class Portfolio:
    def __init__(self, id: int, name: str, db_manager):
        self.id = id
        self.name = name
        self.db_manager = db_manager
        self.stocks: Dict[str, Stock] = {}

    def load_stocks(self):
        stocks_data = self.db_manager.get_stocks_for_portfolio(self.id)
        for stock_data in stocks_data:
            stock = Stock(
                id=stock_data[0],
                yahoo_symbol=stock_data[1],
                instrument_code=stock_data[2],
                name=stock_data[3],
                current_price=stock_data[4],
                last_updated=stock_data[5],
                db_manager=self.db_manager
            )
            stock.load_transactions()
            self.stocks[stock.yahoo_symbol] = stock

    def add_stock(self, stock: Stock):
        self.db_manager.add_stock_to_portfolio(self.id, stock.id)
        self.stocks[stock.yahoo_symbol] = stock

    def remove_stock(self, yahoo_symbol: str):
        if yahoo_symbol in self.stocks:
            stock = self.stocks[yahoo_symbol]
            self.db_manager.remove_stock_from_portfolio(self.id, stock.id)
            del self.stocks[yahoo_symbol]

    def get_stock(self, yahoo_symbol: str) -> Stock:
        return self.stocks.get(yahoo_symbol)

    def update_prices(self):
        for stock in self.stocks.values():
            stock.update_price()

    def calculate_total_value(self) -> float:
        return sum(stock.calculate_market_value() for stock in self.stocks.values())

    def calculate_total_profit_loss(self) -> float:
        return sum(stock.calculate_profit_loss() for stock in self.stocks.values())

    @classmethod
    def create(cls, name: str, db_manager):
        portfolio_id = db_manager.create_portfolio(name)
        return cls(id=portfolio_id, name=name, db_manager=db_manager)

    @classmethod
    def get_all(cls, db_manager):
        portfolios_data = db_manager.get_all_portfolios()
        return [cls(id=data[0], name=data[1], db_manager=db_manager) for data in portfolios_data]

    @classmethod
    def get_by_id(cls, portfolio_id: int, db_manager):
        portfolio_data = db_manager.get_portfolio(portfolio_id)
        if portfolio_data:
            return cls(id=portfolio_data[0], name=portfolio_data[1], db_manager=db_manager)
        return None

================================================================================

File: models\stock.py
--------------------------------------------------------------------------------
# File: models/stock.py

from datetime import datetime
from typing import List
from .transaction import Transaction

class Stock:
    def __init__(self, id: int, yahoo_symbol: str, instrument_code: str, name: str, current_price: float, last_updated: datetime, db_manager):
        self.id = id
        self.yahoo_symbol = yahoo_symbol
        self.instrument_code = instrument_code
        self.name = name
        self.current_price = current_price
        self.last_updated = last_updated
        self.db_manager = db_manager
        self.transactions: List[Transaction] = []

    def load_transactions(self):
        transactions_data = self.db_manager.get_transactions_for_stock(self.id)
        self.transactions = [
            Transaction(
                id=t[0],
                date=self.parse_date(t[1]),
                quantity=t[2],
                price=t[3],
                transaction_type=t[4],
                db_manager=self.db_manager
            ) for t in transactions_data
        ]

    @staticmethod
    def parse_date(date_string: str) -> datetime:
        try:
            return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S')
        except ValueError:
            try:
                return datetime.strptime(date_string, '%Y-%m-%d')
            except ValueError:
                raise ValueError(f"Unable to parse date string: {date_string}")

    def add_transaction(self, transaction: Transaction):
        self.db_manager.add_transaction(
            stock_id=self.id,
            date=transaction.date,
            quantity=transaction.quantity,
            price=transaction.price,
            transaction_type=transaction.transaction_type
        )
        self.transactions.append(transaction)
        
    def update_price(self):
        self.last_updated = datetime.now().replace(microsecond=0)
        self.db_manager.update_stock_price(self.yahoo_symbol, self.current_price)

    def calculate_average_cost(self) -> float:
        total_cost = 0
        total_shares = 0
        for transaction in self.transactions:
            if transaction.transaction_type == 'BUY':
                total_cost += transaction.quantity * transaction.price
                total_shares += transaction.quantity
            elif transaction.transaction_type == 'SELL':
                total_shares -= transaction.quantity
        return total_cost / total_shares if total_shares > 0 else 0

    def calculate_total_shares(self) -> float:
        return sum(t.quantity if t.transaction_type == 'BUY' else -t.quantity for t in self.transactions)

    def calculate_market_value(self) -> float:
        return self.calculate_total_shares() * self.current_price

    def calculate_profit_loss(self) -> float:
        return self.calculate_market_value() - sum(t.quantity * t.price for t in self.transactions if t.transaction_type == 'BUY')

    @classmethod
    def create(cls, yahoo_symbol: str, instrument_code: str, name: str, current_price: float, db_manager):
        stock_id = db_manager.add_stock(yahoo_symbol, instrument_code, name, current_price)
        return cls(
            id=stock_id,
            yahoo_symbol=yahoo_symbol,
            instrument_code=instrument_code,
            name=name,
            current_price=current_price,
            last_updated=datetime.now().replace(microsecond=0),
            db_manager=db_manager
        )

    @classmethod
    def get_by_yahoo_symbol(cls, yahoo_symbol: str, db_manager):
        stock_data = db_manager.get_stock(yahoo_symbol)
        if stock_data:
            return cls(
                id=stock_data[0],
                yahoo_symbol=stock_data[1],
                instrument_code=stock_data[2],
                name=stock_data[3],
                current_price=stock_data[4],
                last_updated=cls.parse_date(stock_data[5]),
                db_manager=db_manager
            )
        return None

================================================================================

File: models\transaction.py
--------------------------------------------------------------------------------
# File: models/transaction.py

from datetime import datetime

class Transaction:
    def __init__(self, id: int, date: datetime, quantity: float, price: float, transaction_type: str, db_manager):
        self.id = id
        self.date = date
        self.quantity = quantity
        self.price = price
        self.transaction_type = transaction_type
        self.db_manager = db_manager

    @classmethod
    def create(cls, stock_id: int, date: datetime, quantity: float, price: float, transaction_type: str, db_manager):
        transaction_id = db_manager.add_transaction(stock_id, date, quantity, price, transaction_type)
        return cls(
            id=transaction_id,
            date=date,
            quantity=quantity,
            price=price,
            transaction_type=transaction_type,
            db_manager=db_manager
        )

================================================================================

File: utils\stock_symbol_manager.py
--------------------------------------------------------------------------------
# File: utils/stock_symbol_manager.py

import json
import os
import yfinance as yf

class StockSymbolManager:
    def __init__(self, config_file='stock_symbols.json'):
        self.config_file = config_file
        self.symbols = self.load_symbols()
        self.market_codes = {
            'Argentina - Buenos Aires Stock Exchange (BYMA)': '.BA',
            'Australia - Australian Stock Exchange': '.AX',
            'Austria - Vienna Stock Exchange': '.VI',
            'Belgium - Euronext Brussels': '.BR',
            'Brazil - Sao Paolo Stock Exchange (BOVESPA)': '.SA',
            'Canada - Canadian Securities Exchange Toronto Stock Exchange': '.CN',
            'Canada - NEO Exchange': '.NE',
            'Canada - Toronto Stock Exchange': '.TO',
            'Canada - TSX Venture Exchange (TSXV)': '.V',
            'Chile - Santiago Stock Exchange': '.SN',
            'China - Shanghai Stock Exchange': '.SS',
            'China - Shenzhen Stock Exchange': '.SZ',
            'Czech Republic - Prague Stock Exchange Index': '.PR',
            'Denmark - Nasdaq OMX Copenhagen': '.CO',
            'Egypt - Egyptian Exchange Index (EGID)': '.CA',
            'Estonia - Nasdaq OMX Tallinn': '.TL',
            'Finland - Nasdaq OMX Helsinki': '.HE',
            'France - Euronext': '.NX',
            'France - Euronext Paris': '.PA',
            'Germany - Berlin Stock Exchange': '.BE',
            'Germany - Bremen Stock Exchange': '.BM',
            'Germany - Dusseldorf Stock Exchange': '.DU',
            'Germany - Frankfurt Stock Exchange': '.F',
            'Germany - Hamburg Stock Exchange': '.HM',
            'Germany - Hanover Stock Exchange': '.HA',
            'Germany - Munich Stock Exchange': '.MU',
            'Germany - Stuttgart Stock Exchange': '.SG',
            'Germany - Deutsche Boerse XETRA': '.DE',
            'Global - Currency Rates': '',
            'Greece - Athens Stock Exchange (ATHEX)': '.AT',
            'Hong Kong - Hong Kong Stock Exchange (HKEX)': '.HK',
            'Hungary - Budapest Stock Exchange': '.BD',
            'Iceland - Nasdaq OMX Iceland': '.IC',
            'India - Bombay Stock Exchange': '.BO',
            'India - National Stock Exchange of India': '.NS',
            'Indonesia - Indonesia Stock Exchange (IDX)': '.JK',
            'Ireland - Euronext Dublin': '.IR',
            'Israel - Tel Aviv Stock Exchange': '.TA',
            'Italy - EuroTLX': '.TI',
            'Italy - Italian Stock Exchange, former Milano': '.MI',
            'Japan - Nikkei Indices': '',
            'Japan - Tokyo Stock Exchange': '.T',
            'Latvia - Nasdaq OMX Riga': '.RG',
            'Lithuania - Nasdaq OMX Vilnius': '.VS',
            'Malaysia - Malaysian Stock Exchange': '.KL',
            'Mexico - Mexico Stock Exchange (BMV)': '.MX',
            'Netherlands - Euronext Amsterdam': '.AS',
            'New Zealand - New Zealand Stock Exchange (NZX)': '.NZ',
            'Norway - Oslo Stock Exchange': '.OL',
            'Portugal - Euronext Lisbon': '.LS',
            'Qatar - Qatar Stock Exchange': '.QA',
            'Russia - Moscow Exchange (MOEX)': '.ME',
            'Singapore - Singapore Stock Exchange': '.SI',
            'South Africa - Johannesburg Stock Exchange': '.Jo',
            'South Korea - Korea Stock Exchange': '.KS',
            'South Korea - KOSDAQ': '.KQ',
            'Spain - Madrid SE C.A.T.S.': '.MC',
            'Saudi Arabia - Saudi Stock Exchange (Tadawul)': '.SAU',
            'Sweden - Nasdaq OMX Stockholm': '.ST',
            'Switzerland - Swiss Exchange (SIX)': '.SW',
            'Taiwan - Taiwan OTC Exchange': '.TWO',
            'Taiwan - Taiwan Stock Exchange (TWSE)': '.TW',
            'Thailand - Stock Exchange of Thailand (SET)': '.BK',
            'Turkey - Borsa İstanbul': '.IS',
            'United Kingdom - FTSE Indices': '',
            'United Kingdom - London Stock Exchange': '.L',
            'United Kingdom - London Stock Exchange': '.IL',
            'United States of America - Chicago Board of Trade (CBOT)': '.CBT',
            'United States of America - Chicago Mercantile Exchange (CME)': '.CME',
            'United States of America - Dow Jones Indexes': '',
            'United States of America - NASDAQ Stock Exchange': '',
            'United States of America - ICE Futures US, former New York Board of Trade': '.NYB',
            'United States of America - New York Commodities Exchange (COMEX)': '.CMX',
            'United States of America - New York Mercantile Exchange (NYMEX)': '.NYM',
            'United States of America - Options Price Reporting Authority (OPRA)': '',
            'United States of America - OTC Bulletin Board Market': '',
            'United States of America - OTC Markets Group': '',
            'United States of America - S & P Indices': '',
            'Venezuela - Caracas Stock Exchange': '.CR',
        }

    def load_symbols(self):
        if os.path.exists(self.config_file):
            with open(self.config_file, 'r') as f:
                symbols = json.load(f)
                # Ensure 'stock_splits' exists for all symbols
                for symbol_data in symbols.values():
                    if 'stock_splits' not in symbol_data:
                        symbol_data['stock_splits'] = {}
                return symbols
        return {}

    def save_symbols(self):
        with open(self.config_file, 'w') as f:
            json.dump(self.symbols, f, indent=2)

    def add_symbol(self, instrument_code, market_or_index=None):
        if instrument_code not in self.symbols:
            self.symbols[instrument_code] = {
                'market_or_index': market_or_index,
                'stock_name': None,
                'yahoo_symbol': self.construct_yahoo_symbol(instrument_code, market_or_index),
                'stock_splits': {},
                'drp': False
            }
            self.save_symbols()

    def update_symbol(self, instrument_code, market_or_index):
        if instrument_code in self.symbols:
            self.symbols[instrument_code]['market_or_index'] = market_or_index
            self.symbols[instrument_code]['yahoo_symbol'] = self.construct_yahoo_symbol(instrument_code, market_or_index)
            self.refresh_stock_info(instrument_code)
            self.save_symbols()

    def construct_yahoo_symbol(self, instrument_code, market_or_index):
        if not market_or_index:
            return instrument_code
        suffix = self.market_codes.get(market_or_index, "")
        return f"{instrument_code}{suffix}" if suffix else instrument_code

    def refresh_stock_info(self, instrument_code):
        if instrument_code in self.symbols:
            yahoo_symbol = self.symbols[instrument_code]['yahoo_symbol']
            try:
                ticker = yf.Ticker(yahoo_symbol)
                info = ticker.info
                self.symbols[instrument_code]['stock_name'] = info.get('longName', 'N/A')
                
                # Fetch and update stock splits
                splits = ticker.splits
                for date, ratio in splits.items():
                    date_str = date.strftime('%Y-%m-%d')
                    self.symbols[instrument_code]['stock_splits'][date_str] = ratio
                
                self.save_symbols()
                return True
            except Exception as e:
                print(f"Error refreshing stock info for {yahoo_symbol}: {str(e)}")
                return False
        return False

    def get_yahoo_symbol(self, instrument_code):
        return self.symbols.get(instrument_code, {}).get('yahoo_symbol', instrument_code)

    def get_all_symbols(self):
        return self.symbols

    def set_yahoo_symbol(self, instrument_code, yahoo_symbol):
        if instrument_code in self.symbols:
            self.symbols[instrument_code]['yahoo_symbol'] = yahoo_symbol
            self.symbols[instrument_code]['market_or_index'] = ''  # Clear market when manually set
            self.save_symbols()

    def get_market_codes(self):
        return self.market_codes

    def set_drp(self, instrument_code, drp_status):
        if instrument_code in self.symbols:
            self.symbols[instrument_code]['drp'] = bool(drp_status)
            self.save_symbols()

    def add_stock_split(self, instrument_code, date, ratio):
        if instrument_code in self.symbols:
            if 'stock_splits' not in self.symbols[instrument_code]:
                self.symbols[instrument_code]['stock_splits'] = {}
            self.symbols[instrument_code]['stock_splits'][date] = ratio
            self.save_symbols()

    def remove_stock_split(self, instrument_code, date):
        if instrument_code in self.symbols and 'stock_splits' in self.symbols[instrument_code]:
            if date in self.symbols[instrument_code]['stock_splits']:
                del self.symbols[instrument_code]['stock_splits'][date]
                self.save_symbols()

================================================================================

File: views\import_transactions_view.py
--------------------------------------------------------------------------------
# File: views/import_transactions_view.py

from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                               QTableWidget, QTableWidgetItem, QFileDialog, 
                               QComboBox, QLabel, QStackedWidget, QHeaderView)
from PySide6.QtCore import Signal
import pandas as pd

class ImportTransactionsView(QWidget):
    import_transactions = Signal(str, dict)  # Emit filename and column mapping
    get_template = Signal()  # Signal to request template download

    def __init__(self):
        super().__init__()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        # File selection
        file_layout = QHBoxLayout()
        self.file_path_label = QLabel("No file selected")
        self.select_file_button = QPushButton("Select File")
        self.get_template_button = QPushButton("Get Template")
        file_layout.addWidget(self.file_path_label)
        file_layout.addWidget(self.select_file_button)
        file_layout.addWidget(self.get_template_button)
        layout.addLayout(file_layout)

        # Stacked widget for different import views
        self.stacked_widget = QStackedWidget()
        
        # Template import view
        template_view = QWidget()
        template_layout = QVBoxLayout(template_view)
        self.template_preview = QTableWidget()
        template_layout.addWidget(QLabel("Template detected. Preview:"))
        template_layout.addWidget(self.template_preview)
        
        # Custom import view
        custom_view = QWidget()
        custom_layout = QVBoxLayout(custom_view)
        self.custom_preview = QTableWidget()
        custom_layout.addWidget(QLabel("Custom file. Please map columns:"))
        custom_layout.addWidget(self.custom_preview)
        
        # Column mapping (only for custom view)
        mapping_layout = QHBoxLayout()
        self.date_combo = QComboBox()
        self.symbol_combo = QComboBox()
        self.quantity_combo = QComboBox()
        self.price_combo = QComboBox()
        self.type_combo = QComboBox()
        mapping_layout.addWidget(QLabel("Date:"))
        mapping_layout.addWidget(self.date_combo)
        mapping_layout.addWidget(QLabel("Symbol:"))
        mapping_layout.addWidget(self.symbol_combo)
        mapping_layout.addWidget(QLabel("Quantity:"))
        mapping_layout.addWidget(self.quantity_combo)
        mapping_layout.addWidget(QLabel("Price:"))
        mapping_layout.addWidget(self.price_combo)
        mapping_layout.addWidget(QLabel("Type:"))
        mapping_layout.addWidget(self.type_combo)
        custom_layout.addLayout(mapping_layout)

        self.stacked_widget.addWidget(template_view)
        self.stacked_widget.addWidget(custom_view)
        layout.addWidget(self.stacked_widget)

        # Import and Cancel buttons
        button_layout = QHBoxLayout()
        self.import_button = QPushButton("Import")
        self.cancel_button = QPushButton("Cancel")
        button_layout.addWidget(self.import_button)
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)

        self.setLayout(layout)

        # Connect signals
        self.select_file_button.clicked.connect(self.select_file)
        self.get_template_button.clicked.connect(self.get_template.emit)
        self.import_button.clicked.connect(self.import_data)
        self.cancel_button.clicked.connect(self.close)

    def select_file(self):
        file_name, _ = QFileDialog.getOpenFileName(self, "Select File", "", "Excel Files (*.xlsx);;CSV Files (*.csv)")
        if file_name:
            self.file_path_label.setText(file_name)
            self.load_preview(file_name)

    def load_preview(self, file_name):
        if file_name.endswith('.xlsx'):
            df = pd.read_excel(file_name, nrows=5)
        elif file_name.endswith('.csv'):
            df = pd.read_csv(file_name, nrows=5)
        else:
            return

        if self.is_template_file(df):
            self.load_template_preview(df)
        else:
            self.load_custom_preview(df)

    def is_template_file(self, df):
        expected_columns = ['Trade Date', 'Instrument Code', 'Quantity', 'Price', 'Transaction Type']
        return all(col in df.columns for col in expected_columns)

    def load_template_preview(self, df):
        self.stacked_widget.setCurrentIndex(0)
        self.populate_table(self.template_preview, df)

    def load_custom_preview(self, df):
        self.stacked_widget.setCurrentIndex(1)
        self.populate_table(self.custom_preview, df)
        self.update_column_mappings(df.columns)

    def populate_table(self, table_widget, df):
        table_widget.setRowCount(df.shape[0])
        table_widget.setColumnCount(df.shape[1])
        table_widget.setHorizontalHeaderLabels(df.columns)

        for row in range(df.shape[0]):
            for col in range(df.shape[1]):
                item = QTableWidgetItem(str(df.iloc[row, col]))
                table_widget.setItem(row, col, item)

        table_widget.resizeColumnsToContents()
        table_widget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

    def update_column_mappings(self, columns):
        for combo in [self.date_combo, self.symbol_combo, self.quantity_combo, self.price_combo, self.type_combo]:
            combo.clear()
            combo.addItems(columns)

    def import_data(self):
        if self.stacked_widget.currentIndex() == 0:
            # Template import
            self.import_transactions.emit(self.file_path_label.text(), None)
        else:
            # Custom import
            column_mapping = {
                'date': self.date_combo.currentText(),
                'symbol': self.symbol_combo.currentText(),
                'quantity': self.quantity_combo.currentText(),
                'price': self.price_combo.currentText(),
                'type': self.type_combo.currentText()
            }
            self.import_transactions.emit(self.file_path_label.text(), column_mapping)
        self.close()

================================================================================

File: views\main_window.py
--------------------------------------------------------------------------------
# File: views/main_window.py

import os
from PySide6.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QPushButton, QStackedWidget, QLabel, QHBoxLayout
from PySide6.QtGui import QIcon, QPixmap
from PySide6.QtCore import Qt

from controllers.portfolio_controller import PortfolioController
from controllers.portfolio_view_controller import PortfolioViewController
from views.market_codes_view import MarketCodesView

class MainWindow(QMainWindow):
    def __init__(self, db_manager):
        super().__init__()
        self.setWindowTitle("Insider Portfolio Manager")
        self.setGeometry(100, 100, 1200, 800)

        self.db_manager = db_manager

        # Create main widget and layout
        main_widget = QWidget()
        main_layout = QHBoxLayout()
        main_widget.setLayout(main_layout)
        self.setCentralWidget(main_widget)

        # Create and set up sidebar
        sidebar = QWidget()
        sidebar.setMaximumWidth(200)
        sidebar.setMinimumWidth(200)
        sidebar_layout = QVBoxLayout()
        sidebar.setLayout(sidebar_layout)

        # Add logo
        logo_label = QLabel()
        current_dir = os.path.dirname(os.path.abspath(__file__))
        logo_path = os.path.join(current_dir, "..", "logo.png")
        logo_pixmap = QPixmap(logo_path)
        logo_label.setPixmap(logo_pixmap.scaled(180, 180, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        logo_label.setAlignment(Qt.AlignCenter)
        sidebar_layout.addWidget(logo_label)

        # Add navigation buttons
        self.nav_buttons = []
        for button_text in ["Manage Portfolios", "My Portfolio", "Analyze Portfolio", "Market Codes", "Settings"]:
            button = QPushButton(button_text)
            button.clicked.connect(lambda checked, text=button_text: self.on_nav_button_clicked(text))
            sidebar_layout.addWidget(button)
            self.nav_buttons.append(button)

        sidebar_layout.addStretch()

        # Create stacked widget for main content
        self.content_widget = QStackedWidget()

        # Create controllers
        self.portfolio_controller = PortfolioController(self.db_manager)
        self.portfolio_view_controller = PortfolioViewController(self.db_manager)
        self.market_codes_view = MarketCodesView(self.db_manager)

        # Connect signals
        self.portfolio_controller.view.select_portfolio.connect(self.on_portfolio_selected)
        self.market_codes_view.refresh_symbol.connect(self.refresh_stock_info)
        self.market_codes_view.update_symbol.connect(self.update_symbol)

        # Add pages to stacked widget
        self.content_widget.addWidget(self.portfolio_controller.get_view())
        self.content_widget.addWidget(self.portfolio_view_controller.get_view())
        self.content_widget.addWidget(QLabel("Analyze Portfolio Page"))
        self.content_widget.addWidget(self.market_codes_view)
        self.content_widget.addWidget(QLabel("Settings Page"))

        # Add sidebar and content to main layout
        main_layout.addWidget(sidebar)
        main_layout.addWidget(self.content_widget)

        # Load initial data
        self.portfolio_controller.load_portfolios()

    def on_nav_button_clicked(self, button_text):
        index = ["Manage Portfolios", "My Portfolio", "Analyze Portfolio", "Market Codes", "Settings"].index(button_text)
        self.content_widget.setCurrentIndex(index)
        for button in self.nav_buttons:
            button.setStyleSheet("")
        self.nav_buttons[index].setStyleSheet("background-color: #ddd;")

    def on_portfolio_selected(self, portfolio_name):
        portfolio = self.portfolio_controller.get_portfolio_by_name(portfolio_name)
        if portfolio:
            self.portfolio_view_controller.set_portfolio(portfolio)
            self.content_widget.setCurrentIndex(1)  # Switch to "My Portfolio" view
            self.nav_buttons[1].setStyleSheet("background-color: #ddd;")

    def refresh_stock_info(self, instrument_code):
        # Implement this method to refresh stock info using db_manager
        # This might involve fetching updated data from an external API
        # and then updating the database
        pass

    def update_symbol(self, instrument_code, market_or_index):
        # Implement this method to update symbol using db_manager
        self.db_manager.update_stock_market(instrument_code, market_or_index)
        # You might want to refresh the view after updating
        self.market_codes_view.update_symbol_data(instrument_code)

================================================================================

File: views\manage_portfolios_view.py
--------------------------------------------------------------------------------
# File: views/manage_portfolios_view.py

from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QListWidget, 
                               QPushButton, QLabel, QLineEdit, QMessageBox,
                               QDialog, QDialogButtonBox, QFormLayout)
from PySide6.QtCore import Signal

class CreatePortfolioDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Create New Portfolio")
        self.layout = QFormLayout(self)

        self.name_input = QLineEdit(self)
        self.layout.addRow("Portfolio Name:", self.name_input)

        self.buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,
            parent=self)
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        self.layout.addRow(self.buttons)

class ManagePortfoliosView(QWidget):
    create_portfolio = Signal(str)
    select_portfolio = Signal(str)
    delete_portfolio = Signal(str)
    import_transactions = Signal(str)

    def __init__(self):
        super().__init__()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        # Portfolio list
        self.portfolio_list = QListWidget()
        layout.addWidget(QLabel("Your Portfolios:"))
        layout.addWidget(self.portfolio_list)

        # Buttons
        button_layout = QHBoxLayout()
        self.create_button = QPushButton("Create New Portfolio")
        self.delete_button = QPushButton("Delete Portfolio")
        self.view_button = QPushButton("View Portfolio")
        self.import_button = QPushButton("Import Transactions")
        self.delete_button.setEnabled(False)
        self.view_button.setEnabled(False)
        self.import_button.setEnabled(False)
        button_layout.addWidget(self.create_button)
        button_layout.addWidget(self.delete_button)
        button_layout.addWidget(self.view_button)
        button_layout.addWidget(self.import_button)
        layout.addLayout(button_layout)

        self.setLayout(layout)

        # Connect signals
        self.create_button.clicked.connect(self.show_create_dialog)
        self.delete_button.clicked.connect(self.delete_selected_portfolio)
        self.view_button.clicked.connect(self.view_selected_portfolio)
        self.import_button.clicked.connect(self.import_transactions_clicked)
        self.portfolio_list.itemSelectionChanged.connect(self.update_button_states)
        self.portfolio_list.itemDoubleClicked.connect(self.on_portfolio_double_clicked)

    def show_create_dialog(self):
        dialog = CreatePortfolioDialog(self)
        if dialog.exec_():
            portfolio_name = dialog.name_input.text().strip()
            if portfolio_name:
                self.create_portfolio.emit(portfolio_name)
            else:
                QMessageBox.warning(self, "Invalid Input", "Portfolio name cannot be empty.")

    def update_portfolios(self, portfolios):
        self.portfolio_list.clear()
        for portfolio in portfolios:
            self.portfolio_list.addItem(portfolio.name)

    def update_button_states(self):
        selected = bool(self.portfolio_list.selectedItems())
        self.delete_button.setEnabled(selected)
        self.view_button.setEnabled(selected)
        self.import_button.setEnabled(selected)

    def delete_selected_portfolio(self):
        selected_item = self.portfolio_list.currentItem()
        if selected_item:
            confirm = QMessageBox.question(self, "Confirm Deletion",
                                           f"Are you sure you want to delete the portfolio '{selected_item.text()}'?",
                                           QMessageBox.Yes | QMessageBox.No)
            if confirm == QMessageBox.Yes:
                self.delete_portfolio.emit(selected_item.text())

    def view_selected_portfolio(self):
        selected_item = self.portfolio_list.currentItem()
        if selected_item:
            self.select_portfolio.emit(selected_item.text())

    def on_portfolio_double_clicked(self, item):
        self.select_portfolio.emit(item.text())

    def import_transactions_clicked(self):
        selected_item = self.portfolio_list.currentItem()
        if selected_item:
            self.import_transactions.emit(selected_item.text())
        else:
            QMessageBox.warning(self, "No Portfolio Selected", "Please select a portfolio to import transactions into.")

================================================================================

File: views\manage_stock_splits_dialog.py
--------------------------------------------------------------------------------
# File: views/manage_stock_splits_dialog.py

from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, 
                               QTableWidget, QTableWidgetItem, QHeaderView,
                               QLabel, QDateEdit, QDoubleSpinBox, QMessageBox)
from PySide6.QtCore import Qt
from datetime import datetime

class ManageStockSplitsDialog(QDialog):
    def __init__(self, db_manager, instrument_code, parent=None):
        super().__init__(parent)
        self.db_manager = db_manager
        self.instrument_code = instrument_code
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle(f"Manage Stock Splits - {self.instrument_code}")
        layout = QVBoxLayout()

        # Table for existing splits
        self.splits_table = QTableWidget()
        self.splits_table.setColumnCount(3)  # Date, Ratio, Delete button
        self.splits_table.setHorizontalHeaderLabels(["Date", "Ratio", ""])
        self.splits_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        layout.addWidget(self.splits_table)

        # Add new split section
        add_split_layout = QHBoxLayout()
        add_split_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit()
        self.date_edit.setCalendarPopup(True)
        self.date_edit.setDate(datetime.now().date())
        add_split_layout.addWidget(self.date_edit)

        add_split_layout.addWidget(QLabel("Ratio:"))
        self.ratio_spin = QDoubleSpinBox()
        self.ratio_spin.setRange(0.01, 100)
        self.ratio_spin.setValue(2)
        self.ratio_spin.setDecimals(2)
        add_split_layout.addWidget(self.ratio_spin)

        self.add_button = QPushButton("Add Split")
        self.add_button.clicked.connect(self.add_split)
        add_split_layout.addWidget(self.add_button)

        layout.addLayout(add_split_layout)

        # Close button
        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        layout.addWidget(self.close_button)

        self.setLayout(layout)

        self.load_splits()

    def load_splits(self):
        stock = self.db_manager.get_stock(self.instrument_code)
        splits = self.db_manager.get_stock_splits(stock['id'])
        self.splits_table.setRowCount(len(splits))
        for row, split in enumerate(splits):
            self.splits_table.setItem(row, 0, QTableWidgetItem(split['date']))
            self.splits_table.setItem(row, 1, QTableWidgetItem(str(split['ratio'])))
            delete_button = QPushButton("Delete")
            delete_button.clicked.connect(lambda _, r=row: self.delete_split(r))
            self.splits_table.setCellWidget(row, 2, delete_button)

    def add_split(self):
        date = self.date_edit.date().toString("yyyy-MM-dd")
        ratio = self.ratio_spin.value()
        stock = self.db_manager.get_stock(self.instrument_code)
        self.db_manager.add_stock_split(stock['id'], date, ratio)
        self.load_splits()

    def delete_split(self, row):
        date = self.splits_table.item(row, 0).text()
        confirm = QMessageBox.question(self, "Confirm Deletion",
                                       f"Are you sure you want to delete the stock split on {date}?",
                                       QMessageBox.Yes | QMessageBox.No)
        if confirm == QMessageBox.Yes:
            stock = self.db_manager.get_stock(self.instrument_code)
            self.db_manager.remove_stock_split(stock['id'], date)
            self.load_splits()

================================================================================

File: views\market_codes_view.py
--------------------------------------------------------------------------------
# File: views/market_codes_view.py

from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                               QTableWidget, QTableWidgetItem, QHeaderView,
                               QComboBox, QStyledItemDelegate, QCheckBox)
from PySide6.QtCore import Signal, Qt
from PySide6.QtGui import QColor
from .manage_stock_splits_dialog import ManageStockSplitsDialog

class ReadOnlyDelegate(QStyledItemDelegate):
    def createEditor(self, parent, option, index):
        return None

class MarketCodesView(QWidget):
    refresh_symbol = Signal(str)
    update_symbol = Signal(str, str)

    def __init__(self, db_manager):
        super().__init__()
        self.db_manager = db_manager
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        # Create table
        self.table = QTableWidget()
        self.table.setColumnCount(6)
        self.table.setHorizontalHeaderLabels(["Instrument Code", "Market or Index", "Stock Name", "Yahoo Finance Symbol", "Stock Splits", "DRP"])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setSortingEnabled(True)  # Enable sorting
        layout.addWidget(self.table)

        # Set up delegates
        read_only_delegate = ReadOnlyDelegate(self.table)
        self.table.setItemDelegateForColumn(0, read_only_delegate)
        self.table.setItemDelegateForColumn(2, read_only_delegate)
        self.table.setItemDelegateForColumn(4, read_only_delegate)

        # Create buttons
        button_layout = QHBoxLayout()
        self.refresh_button = QPushButton("Refresh Selected")
        self.refresh_button.clicked.connect(self.refresh_selected)
        button_layout.addWidget(self.refresh_button)

        self.refresh_all_button = QPushButton("Refresh All")
        self.refresh_all_button.clicked.connect(self.refresh_all)
        button_layout.addWidget(self.refresh_all_button)

        layout.addLayout(button_layout)

        self.setLayout(layout)

        self.load_data()

    def load_data(self):
        symbols = self.db_manager.get_all_stocks()
        market_codes = self.db_manager.get_all_market_codes()
        
        self.table.setRowCount(len(symbols))
        for row, stock_data in enumerate(symbols):
            # Assuming the order: id, yahoo_symbol, instrument_code, name, current_price, last_updated, market_suffix, drp
            stock_id = stock_data[0]
            instrument_code = stock_data[2]
            name = stock_data[3]
            yahoo_symbol = stock_data[1]
            market_suffix = stock_data[6]
            drp_status = stock_data[7]

            self.table.setItem(row, 0, QTableWidgetItem(instrument_code))
            
            market_combo = QComboBox()
            market_combo.addItem("", "")  # Empty option
            for code in market_codes:
                market_combo.addItem(f"{code[1]} ({code[2]})", code[2])  # market_or_index (market_suffix), data is market_suffix
            
            if market_suffix:
                index = market_combo.findData(market_suffix)
                if index >= 0:
                    market_combo.setCurrentIndex(index)
            
            market_combo.currentIndexChanged.connect(lambda index, r=row: self.on_market_changed(r, index))
            self.table.setCellWidget(row, 1, market_combo)
            
            self.table.setItem(row, 2, QTableWidgetItem(name))
            self.table.setItem(row, 3, QTableWidgetItem(yahoo_symbol))

            # Stock Splits
            splits = self.db_manager.get_stock_splits(stock_data[0])
            splits_text = ", ".join(f"{split[0]}: {split[1]}" for split in splits)
            splits_item = QTableWidgetItem(splits_text)
            splits_item.setForeground(QColor(0, 0, 255))  # Blue color to indicate it's clickable
            self.table.setItem(row, 4, splits_item)

            # DRP
            drp_checkbox = QCheckBox()
            drp_checkbox.setChecked(drp_status)
            drp_checkbox.stateChanged.connect(lambda state, r=row, s_id=stock_id: self.on_drp_changed(r, s_id, state))
            self.table.setCellWidget(row, 5, drp_checkbox)

        self.table.cellChanged.connect(self.on_cell_changed)
        self.table.cellDoubleClicked.connect(self.on_cell_double_clicked)

    def on_market_changed(self, row, index):
        instrument_code = self.table.item(row, 0).text()
        market_combo = self.table.cellWidget(row, 1)
        market_suffix = market_combo.itemData(index)
        self.update_symbol.emit(instrument_code, market_suffix)
        self.db_manager.update_stock_market(instrument_code, market_suffix)
        self.update_symbol_data(instrument_code)

    def update_symbol_data(self, instrument_code):
        stock_data = self.db_manager.get_stock(instrument_code)
        if stock_data:
            for row in range(self.table.rowCount()):
                if self.table.item(row, 0).text() == instrument_code:
                    # Assuming the order: id, yahoo_symbol, instrument_code, name, current_price, last_updated, market_suffix
                    self.table.item(row, 2).setText(stock_data[3])  # name
                    self.table.item(row, 3).setText(stock_data[1])  # yahoo_symbol
                    
                    market_combo = self.table.cellWidget(row, 1)
                    index = market_combo.findData(stock_data[6])  # market_suffix
                    if index >= 0:
                        market_combo.setCurrentIndex(index)

                    # Update Stock Splits
                    splits = self.db_manager.get_stock_splits(stock_data[0])
                    splits_text = ", ".join(f"{split[0]}: {split[1]}" for split in splits)
                    self.table.item(row, 4).setText(splits_text)
                    
                    # Update DRP
                    drp_checkbox = self.table.cellWidget(row, 5)
                    drp_checkbox.setChecked(self.db_manager.get_stock_drp(stock_data[0]))
                    
                    break

    def on_cell_changed(self, row, column):
        if column == 3:  # Yahoo Finance Symbol column
            instrument_code = self.table.item(row, 0).text()
            yahoo_symbol = self.table.item(row, 3).text()
            self.db_manager.update_stock_yahoo_symbol(instrument_code, yahoo_symbol)
    
    def on_drp_changed(self, row, stock_id, state):
        checkbox = self.table.cellWidget(row, 5)
        is_checked = checkbox.isChecked()
        instrument_code = self.table.item(row, 0).text()
        self.db_manager.update_stock_drp(stock_id, is_checked)
        print(f"DRP status changed for stock ID {stock_id} (Instrument Code: {instrument_code}) to {is_checked}")

    def on_cell_double_clicked(self, row, column):
        if column == 4:  # Stock Splits column
            instrument_code = self.table.item(row, 0).text()
            dialog = ManageStockSplitsDialog(self.db_manager, instrument_code, self)
            if dialog.exec_():
                self.update_symbol_data(instrument_code)

    def refresh_selected(self):
        selected_rows = set(index.row() for index in self.table.selectedIndexes())
        for row in selected_rows:
            instrument_code = self.table.item(row, 0).text()
            self.refresh_symbol.emit(instrument_code)
            self.update_symbol_data(instrument_code)

    def refresh_all(self):
        for row in range(self.table.rowCount()):
            instrument_code = self.table.item(row, 0).text()
            self.refresh_symbol.emit(instrument_code)
            self.update_symbol_data(instrument_code)

================================================================================

File: views\my_portfolio_view.py
--------------------------------------------------------------------------------
# File: views/my_portfolio_view.py

from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
                               QPushButton, QTableWidget, QTableWidgetItem, 
                               QHeaderView)
from PySide6.QtCore import Qt, Signal

class MyPortfolioView(QWidget):
    add_stock = Signal()
    remove_stock = Signal(str)
    refresh_data = Signal()

    def __init__(self):
        super().__init__()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        # Portfolio name and value
        self.portfolio_name_label = QLabel("Portfolio Name")
        self.portfolio_value_label = QLabel("Total Value: $0.00")
        layout.addWidget(self.portfolio_name_label)
        layout.addWidget(self.portfolio_value_label)

        # Buttons
        button_layout = QHBoxLayout()
        self.add_stock_button = QPushButton("Add Stock")
        self.remove_stock_button = QPushButton("Remove Stock")
        self.refresh_button = QPushButton("Refresh Data")
        button_layout.addWidget(self.add_stock_button)
        button_layout.addWidget(self.remove_stock_button)
        button_layout.addWidget(self.refresh_button)
        layout.addLayout(button_layout)

        # Stocks table
        self.stocks_table = QTableWidget()
        self.stocks_table.setColumnCount(8)
        self.stocks_table.setHorizontalHeaderLabels([
            "Yahoo Symbol", "Instrument Code", "Name", "Quantity", "Avg Cost", "Current Price", "Market Value", "Gain/Loss"
        ])
        self.stocks_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        layout.addWidget(self.stocks_table)

        self.setLayout(layout)

        # Connect signals
        self.add_stock_button.clicked.connect(self.add_stock)
        self.remove_stock_button.clicked.connect(self.on_remove_stock)
        self.refresh_button.clicked.connect(self.refresh_data)

    def on_remove_stock(self):
        selected_items = self.stocks_table.selectedItems()
        if selected_items:
            yahoo_symbol = self.stocks_table.item(selected_items[0].row(), 0).text()
            self.remove_stock.emit(yahoo_symbol)

    def update_portfolio(self, portfolio):
        self.portfolio_name_label.setText(portfolio.name)
        self.portfolio_value_label.setText(f"Total Value: ${portfolio.calculate_total_value():.2f}")

        self.stocks_table.setRowCount(len(portfolio.stocks))
        for row, (yahoo_symbol, stock) in enumerate(portfolio.stocks.items()):
            self.stocks_table.setItem(row, 0, QTableWidgetItem(yahoo_symbol))
            self.stocks_table.setItem(row, 1, QTableWidgetItem(stock.instrument_code))
            self.stocks_table.setItem(row, 2, QTableWidgetItem(stock.name))
            self.stocks_table.setItem(row, 3, QTableWidgetItem(str(stock.calculate_total_shares())))
            self.stocks_table.setItem(row, 4, QTableWidgetItem(f"${stock.calculate_average_cost():.2f}"))
            self.stocks_table.setItem(row, 5, QTableWidgetItem(f"${stock.current_price:.2f}"))
            self.stocks_table.setItem(row, 6, QTableWidgetItem(f"${stock.calculate_market_value():.2f}"))
            gain_loss = stock.calculate_profit_loss()
            self.stocks_table.setItem(row, 7, QTableWidgetItem(f"${gain_loss:.2f}"))
            
            # Color code the gain/loss cell
            gain_loss_item = self.stocks_table.item(row, 7)
            gain_loss_item.setForeground(Qt.green if gain_loss >= 0 else Qt.red)

================================================================================

File: views\verify_transactions_view.py
--------------------------------------------------------------------------------
# File: views/verify_transactions_view.py

from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, 
                              QTableWidget, QTableWidgetItem, QHeaderView,
                              QComboBox, QMessageBox, QLabel)
from PySide6.QtCore import Qt, Signal

from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, 
                              QTableWidget, QTableWidgetItem, QHeaderView,
                              QComboBox, QMessageBox, QLabel, QProgressDialog,
                              QDateEdit, QDoubleSpinBox, QMenu, QDialogButtonBox)
from PySide6.QtCore import Qt, Signal
from datetime import datetime
import yfinance as yf
import concurrent.futures

class VerifyTransactionsDialog(QDialog):
    verification_completed = Signal(dict)  # Emits final verification results

    def __init__(self, transactions_data, db_manager, parent=None):
        super().__init__(parent)
        self.db_manager = db_manager
        self.transactions_data = transactions_data
        self.market_mappings = {}
        self.stock_data = {}
        self.verification_status = {}
        self.init_ui()
        
    def init_ui(self):
        self.setWindowTitle("Verify Imported Transactions")
        self.setMinimumWidth(1000)
        self.setMinimumHeight(600)
        
        layout = QVBoxLayout(self)
        
        # Instructions
        instructions = QLabel(
            "Please verify the imported stocks. You can:\n"
            "• Assign market codes to each instrument\n"
            "• Verify stock information with Yahoo Finance\n"
            "• Manage stock splits\n"
            "• Re-verify stocks after making changes"
        )
        layout.addWidget(instructions)
        
        # Main table
        self.table = QTableWidget()
        self.table.setColumnCount(8)
        self.table.setHorizontalHeaderLabels([
            "Instrument Code",
            "Market",
            "Yahoo Symbol",
            "Stock Name",
            "Latest Price",
            "Splits",
            "Status",
            "Actions"
        ])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_context_menu)
        layout.addWidget(self.table)
        
        # Buttons bar
        button_layout = QHBoxLayout()
        
        # Left side buttons
        self.verify_all_btn = QPushButton("Verify All with Yahoo")
        self.verify_all_btn.clicked.connect(self.verify_all_stocks)
        button_layout.addWidget(self.verify_all_btn)
        
        button_layout.addStretch()
        
        # Right side buttons
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.Cancel | QDialogButtonBox.Ok,
            parent=self
        )
        self.buttons.accepted.connect(self.accept)
        self.buttons.rejected.connect(self.reject)
        button_layout.addWidget(self.buttons)
        
        layout.addLayout(button_layout)
        
        # Initialize table data
        self.populate_table()

    def populate_table(self):
        # Get unique instrument codes from transactions
        print(type(self.transactions_data))  # Add this at start of populate_table
        print(self.transactions_data.head()) # If it is a DataFrame
        instrument_codes = self.transactions_data['Instrument Code'].unique()
        self.table.setRowCount(len(instrument_codes))
        
        market_codes = self.db_manager.get_all_market_codes()
        
        for row, instrument_code in enumerate(instrument_codes):
            # Instrument Code
            self.table.setItem(row, 0, QTableWidgetItem(instrument_code))
            
            # Market Combo Box
            market_combo = QComboBox()
            market_combo.addItem("")  # Empty option
            for market_or_index, suffix in market_codes:
                market_combo.addItem(market_or_index, suffix)
            market_combo.currentIndexChanged.connect(
                lambda idx, r=row: self.on_market_changed(r)
            )
            self.table.setCellWidget(row, 1, market_combo)
            
            # Set existing market if available
            existing_stock = self.db_manager.get_stock(instrument_code)
            if existing_stock and existing_stock[6]:  # market_suffix
                market_suffix = existing_stock[6]
                index = market_combo.findData(market_suffix)
                if index >= 0:
                    market_combo.setCurrentIndex(index)
            
            # Yahoo Symbol (will be updated when market is selected)
            self.table.setItem(row, 2, QTableWidgetItem(""))
            
            # Stock Name (will be populated from Yahoo)
            self.table.setItem(row, 3, QTableWidgetItem(""))
            
            # Latest Price
            self.table.setItem(row, 4, QTableWidgetItem(""))
            
            # Splits (button will be added when data is available)
            self.table.setItem(row, 5, QTableWidgetItem(""))
            
            # Status
            status_item = QTableWidgetItem("Pending")
            status_item.setForeground(Qt.gray)
            self.table.setItem(row, 6, status_item)
            
            # Actions Button
            actions_btn = QPushButton("Actions ▼")
            actions_btn.clicked.connect(lambda _, r=row: self.show_actions_menu(r))
            self.table.setCellWidget(row, 7, actions_btn)

    def on_market_changed(self, row):
        instrument_code = self.table.item(row, 0).text()
        market_combo = self.table.cellWidget(row, 1)
        market_suffix = market_combo.currentData()
        
        # Update Yahoo Symbol
        yahoo_symbol = f"{instrument_code}{market_suffix}" if market_suffix else instrument_code
        self.table.item(row, 2).setText(yahoo_symbol)
        
        # Reset verification status
        self.update_status(row, "Pending", Qt.gray)
        
        # Store mapping
        self.market_mappings[instrument_code] = market_suffix

    def verify_all_stocks(self):
        progress = QProgressDialog("Verifying stocks with Yahoo Finance...", "Cancel", 0, self.table.rowCount(), self)
        progress.setWindowModality(Qt.WindowModal)
        
        for row in range(self.table.rowCount()):
            if progress.wasCanceled():
                break
                
            self.verify_stock(row)
            progress.setValue(row + 1)
        
        progress.close()

    def verify_stock(self, row):
        instrument_code = self.table.item(row, 0).text()
        yahoo_symbol = self.table.item(row, 2).text()
        
        if not yahoo_symbol:
            self.update_status(row, "No Symbol", Qt.red)
            return
        
        try:
            ticker = yf.Ticker(yahoo_symbol)
            info = ticker.info
            
            # Update stock name
            name = info.get('longName', 'N/A')
            self.table.item(row, 3).setText(name)
            
            # Update latest price
            price = info.get('currentPrice', 'N/A')
            self.table.item(row, 4).setText(str(price))
            
            # Get splits
            splits = ticker.splits
            if not splits.empty:
                splits_text = [f"{date.strftime('%Y-%m-%d')}: {ratio}" 
                             for date, ratio in splits.items()]
                self.table.item(row, 5).setText(", ".join(splits_text))
                
                # Store splits for later
                self.stock_data[instrument_code] = {
                    'splits': splits,
                    'name': name,
                    'price': price
                }
            
            self.update_status(row, "Verified", Qt.green)
            
        except Exception as e:
            self.update_status(row, "Failed", Qt.red)
            print(f"Error verifying {yahoo_symbol}: {str(e)}")

    def update_status(self, row, status, color):
        status_item = self.table.item(row, 6)
        status_item.setText(status)
        status_item.setForeground(color)
        self.verification_status[row] = status

    def show_actions_menu(self, row):
        menu = QMenu(self)
        
        verify_action = menu.addAction("Verify with Yahoo")
        verify_action.triggered.connect(lambda: self.verify_stock(row))
        
        manage_splits_action = menu.addAction("Manage Splits")
        manage_splits_action.triggered.connect(lambda: self.manage_splits(row))
        
        # Show menu at button
        button = self.table.cellWidget(row, 7)
        menu.exec_(button.mapToGlobal(button.rect().bottomLeft()))

    def manage_splits(self, row):
        instrument_code = self.table.item(row, 0).text()
        dialog = StockSplitsDialog(
            self.db_manager,
            instrument_code,
            initial_splits=self.stock_data.get(instrument_code, {}).get('splits', []),
            parent=self
        )
        if dialog.exec_():
            # Update splits display in table
            splits = dialog.get_splits()
            splits_text = [f"{date}: {ratio}" for date, ratio in splits]
            self.table.item(row, 5).setText(", ".join(splits_text))

    def show_context_menu(self, position):
        menu = QMenu(self)
        row = self.table.rowAt(position.y())
        
        if row >= 0:
            verify_action = menu.addAction("Verify with Yahoo")
            verify_action.triggered.connect(lambda: self.verify_stock(row))
            
            manage_splits_action = menu.addAction("Manage Splits")
            manage_splits_action.triggered.connect(lambda: self.manage_splits(row))
            
            menu.exec_(self.table.viewport().mapToGlobal(position))

    def accept(self):
        # Check if all stocks have been verified
        unverified = [row for row, status in self.verification_status.items() 
                     if status != "Verified"]
        
        if unverified:
            response = QMessageBox.question(
                self,
                "Unverified Stocks",
                "Some stocks haven't been verified. Continue anyway?",
                QMessageBox.Yes | QMessageBox.No
            )
            if response == QMessageBox.No:
                return
        
        # Emit verification results
        results = {
            'market_mappings': self.market_mappings,
            'stock_data': self.stock_data,
            'verification_status': self.verification_status
        }
        self.verification_completed.emit(results)
        super().accept()

class StockSplitsDialog(QDialog):
    def __init__(self, db_manager, instrument_code, initial_splits=None, parent=None):
        super().__init__(parent)
        self.db_manager = db_manager
        self.instrument_code = instrument_code
        self.initial_splits = initial_splits or {}
        self.splits = {}  # Will store current splits
        self.init_ui()
        self.load_splits()

    def init_ui(self):
        self.setWindowTitle(f"Manage Stock Splits - {self.instrument_code}")
        self.setMinimumWidth(400)
        layout = QVBoxLayout(self)

        # Add explanation
        layout.addWidget(QLabel(
            "Manage stock splits for this instrument. "
            "A split ratio of 2 means 2-for-1 split (quantity doubles, price halves)."
        ))

        # Table for existing splits
        self.splits_table = QTableWidget()
        self.splits_table.setColumnCount(3)  # Date, Ratio, Delete button
        self.splits_table.setHorizontalHeaderLabels(["Date", "Ratio", ""])
        self.splits_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        layout.addWidget(self.splits_table)

        # Add new split section
        add_split_layout = QHBoxLayout()
        
        # Date input
        add_split_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit()
        self.date_edit.setCalendarPopup(True)
        self.date_edit.setDate(datetime.now().date())
        add_split_layout.addWidget(self.date_edit)

        # Ratio input
        add_split_layout.addWidget(QLabel("Ratio:"))
        self.ratio_spin = QDoubleSpinBox()
        self.ratio_spin.setRange(0.01, 100)
        self.ratio_spin.setValue(2)
        self.ratio_spin.setDecimals(2)
        add_split_layout.addWidget(self.ratio_spin)

        # Add button
        self.add_button = QPushButton("Add Split")
        self.add_button.clicked.connect(self.add_split)
        add_split_layout.addWidget(self.add_button)

        layout.addLayout(add_split_layout)

        # Dialog buttons
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        )
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def load_splits(self):
        # Load initial splits (from Yahoo or database)
        self.splits = self.initial_splits.copy()
        self.refresh_table()

    def refresh_table(self):
        self.splits_table.setRowCount(len(self.splits))
        for row, (date, ratio) in enumerate(self.splits.items()):
            # Date
            date_item = QTableWidgetItem(date.strftime('%Y-%m-%d') if isinstance(date, datetime) else date)
            self.splits_table.setItem(row, 0, date_item)
            
            # Ratio
            ratio_item = QTableWidgetItem(str(ratio))
            self.splits_table.setItem(row, 1, ratio_item)
            
            # Delete button
            delete_button = QPushButton("Delete")
            delete_button.clicked.connect(lambda _, r=row: self.delete_split(r))
            self.splits_table.setCellWidget(row, 2, delete_button)

    def add_split(self):
        date = self.date_edit.date().toPython()
        ratio = self.ratio_spin.value()
        
        # Add to splits dictionary
        self.splits[date] = ratio
        self.refresh_table()

    def delete_split(self, row):
        date_item = self.splits_table.item(row, 0)
        date_str = date_item.text()
        date = datetime.strptime(date_str, '%Y-%m-%d').date()
        
        confirm = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the stock split on {date_str}?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if confirm == QMessageBox.Yes:
            if date in self.splits:
                del self.splits[date]
            self.refresh_table()

    def get_splits(self):
        return self.splits

================================================================================

